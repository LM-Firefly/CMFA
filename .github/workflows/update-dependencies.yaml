name: Update Clash-Core and Go Modules
on:
  repository_dispatch:
    types:
      - core-updated
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  update-dependencies:
    runs-on: ubuntu-latest
    env:
      GIT_TOKEN: ${{secrets.ACTIONS_TOKEN}}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5

      - name: Checkout and Update submodules
        run: git submodule update --init --recursive --remote --force

      - name: Setup Java (JDK 24)
        uses: actions/setup-java@v5
        with:
          distribution: "temurin"
          java-version: 24

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: "1.25"

      - uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install update-go-mod-replace
        run: |
          go install github.com/metacubex/update-go-mod-replace@latest

      - name: Update Foss Gomod
        run: |
          cd ${{ github.workspace }}/core/src/foss/golang/
          update-go-mod-replace ${{ github.workspace }}/core/src/foss/golang/clash/go.mod $(pwd)/go.mod
          go mod tidy

      - name: Update Main Gomod
        run: |
          cd ${{ github.workspace }}/core/src/main/golang/
          update-go-mod-replace ${{ github.workspace }}/core/src/foss/golang/clash/go.mod $(pwd)/go.mod
          go mod tidy

      #      - uses: tibdex/github-app-token@v2
      #        id: generate-token
      #        with:
      #          app_id: ${{ secrets.MAINTAINER_APPID }}
      #          private_key: ${{ secrets.MAINTAINER_APP_PRIVATE_KEY }}

      # 使用 GitHub API 创建带 Verified 签名的提交并打开 PR
      - name: Create commit and PR via GitHub API (Verified)
        id: create_commit_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');
            const path = require('path');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branchName = 'update-dependencies';

            // 1) 获取默认分支
            const { data: repoData } = await github.rest.repos.get({ owner, repo });
            const baseBranch = repoData.default_branch;

            // 2) 获取默认分支的 head OID
            const { data: baseRef } = await github.rest.git.getRef({ owner, repo, ref: `heads/${baseBranch}` });
            const baseOid = baseRef.object.sha;

            // 3) 确保工作分支存在；如不存在则从默认分支创建
            let branchOid = baseOid;
            try {
              const { data: branchRef } = await github.rest.git.getRef({ owner, repo, ref: `heads/${branchName}` });
              branchOid = branchRef.object.sha;
            } catch (e) {
              const { data: newRef } = await github.rest.git.createRef({ owner, repo, ref: `refs/heads/${branchName}`, sha: baseOid });
              branchOid = newRef.object.sha;
            }

            // 4) 收集本地变更，构造 additions/deletions
            const status = execSync('git status --porcelain', { encoding: 'utf8' }).trim();
            if (!status) {
              core.info('No changes detected. Skipping commit/PR creation.');
              core.setOutput('skipped', 'true');
              return;
            }

            const lines = status.split('\n').filter(Boolean);
            const additions = [];
            const deletions = [];
            let skippedPaths = [];
            let hasSubmoduleChange = false;

            for (const line of lines) {
              const code = line.slice(0, 2);
              let filePath = line.slice(3).trim();

              // 处理重命名："R  old -> new"，作为删除+新增
              if (code.startsWith('R')) {
                const [from, to] = filePath.split(' -> ');
                deletions.push({ path: from.replace(/\\/g, '/') });
                filePath = to;
              }

              // 删除
              if (code.includes('D')) {
                deletions.push({ path: filePath.replace(/\\/g, '/') });
                continue;
              }

              // 忽略子模块和目录，仅处理普通文件
              const absPath = path.join(process.env.GITHUB_WORKSPACE || process.cwd(), filePath);
              try {
                // 判断是否子模块（gitlink，mode 160000）
                try {
                  const ls = execSync(`git ls-files -s -- "${filePath}"`, { encoding: 'utf8' }).trim();
                  if (ls && /\b160000\b/.test(ls)) {
                    hasSubmoduleChange = true;
                    skippedPaths.push(filePath + ' (submodule)');
                    continue;
                  }
                } catch (e) {
                  // ignore
                }

                const stat = fs.existsSync(absPath) ? fs.lstatSync(absPath) : null;
                if (!stat || !stat.isFile()) {
                  skippedPaths.push(filePath + (stat && stat.isDirectory() ? ' (directory)' : ' (not a file)'));
                  continue;
                }

                const content = fs.readFileSync(absPath);
                const b64 = content.toString('base64');
                additions.push({ path: filePath.replace(/\\/g, '/'), contents: b64 });
              } catch (e) {
                skippedPaths.push(filePath + ' (read error)');
                continue;
              }
            }

            if (additions.length === 0 && deletions.length === 0) {
              core.info('No applicable changes for commit.');
              core.setOutput('skipped', 'true');
              // 即便没有普通文件变更，也输出是否存在子模块变化供后续步骤判断
              core.setOutput('has_submodule_change', hasSubmoduleChange ? 'true' : 'false');
              core.setOutput('branch_name', branchName);
              return;
            }

            if (skippedPaths.length) {
              core.info('Skipped paths (not committed via GraphQL fileChanges):\n' + skippedPaths.map(p => ' - ' + p).join('\n'));
            }
            if (hasSubmoduleChange) {
              core.info('Detected submodule changes. Note: GraphQL createCommitOnBranch does not update gitlinks; consider handling submodule pointer updates via a separate signed commit step.');
            }

            // 5) GraphQL mutation：创建提交（GitHub 自动 Verified 签名）
            const mutation = `
              mutation($input: CreateCommitOnBranchInput!) {
                createCommitOnBranch(input: $input) {
                  commit { oid url }
                }
              }
            `;

            const input = {
              branch: { repositoryNameWithOwner: `${owner}/${repo}`, branchName },
              message: {
                headline: 'Update Dependencies',
                body: '- Update Clash-Meta Core\n- Update Go Module Dependencies'
              },
              expectedHeadOid: branchOid,
              fileChanges: { additions, deletions }
            };

            const result = await github.graphql(mutation, { input });
            core.info(`Created commit: ${JSON.stringify(result.createCommitOnBranch.commit)}`);

            // 6) 创建/复用 PR
            // 如果已有打开的 PR 指向该分支，则复用
            const { data: prs } = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${branchName}`, base: baseBranch });
            let pr;
            if (prs.length > 0) {
              pr = prs[0];
            } else {
              const created = await github.rest.pulls.create({
                owner,
                repo,
                title: 'Update Dependencies',
                head: branchName,
                base: baseBranch,
                body: '- Update Clash-Meta Core\n- Update Go Module Dependencies',
                maintainer_can_modify: true,
                draft: false
              });
              pr = created.data;
            }

            core.setOutput('pr_number', pr.number.toString());
            core.setOutput('pr_url', pr.html_url);
            core.setOutput('has_submodule_change', hasSubmoduleChange ? 'true' : 'false');
            core.setOutput('branch_name', branchName);

      - name: Commit submodule pointer (SSH-signed)
        if: ${{ steps.create_commit_pr.outputs.has_submodule_change == 'true' && secrets.SIGNING_SSH_PRIVATE_KEY != '' }}
        shell: bash
        run: |
          set -euo pipefail
          # Prepare SSH signing key
          mkdir -p ~/.ssh
          echo "${{ secrets.SIGNING_SSH_PRIVATE_KEY }}" > ~/.ssh/signing_key
          chmod 600 ~/.ssh/signing_key

          # Commit identity (fallback to GitHub Actions bot if not provided)
          COMMIT_NAME="${{ secrets.COMMITTER_NAME }}"; [ -z "$COMMIT_NAME" ] && COMMIT_NAME="github-actions[bot]"
          COMMIT_EMAIL="${{ secrets.COMMITTER_EMAIL }}"; [ -z "$COMMIT_EMAIL" ] && COMMIT_EMAIL="41898282+github-actions[bot]@users.noreply.github.com"

          git config --global user.name "$COMMIT_NAME"
          git config --global user.email "$COMMIT_EMAIL"
          git config --global gpg.format ssh
          git config --global user.signingkey ~/.ssh/signing_key
          git config --global commit.gpgsign true

          # Ensure local branch is up-to-date with remote
          BRANCH="${{ steps.create_commit_pr.outputs.branch_name }}"
          git fetch origin "$BRANCH"
          git checkout -B "$BRANCH" "origin/$BRANCH"

          # Stage submodule pointer changes
          git add core/src/foss/golang/clash || true
          [ -f .gitmodules ] && git add .gitmodules || true

          # If nothing to commit, exit quietly
          if git diff --cached --quiet; then
            echo "No submodule pointer changes to commit (SSH)."
            exit 0
          fi

          git commit -m "Update submodule: core/src/foss/golang/clash"
          git push origin HEAD:"$BRANCH"

      - name: Commit submodule pointer (GPG-signed)
        if: ${{ steps.create_commit_pr.outputs.has_submodule_change == 'true' && (secrets.SIGNING_SSH_PRIVATE_KEY == '' && secrets.GPG_PRIVATE_KEY != '') }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --kill gpg-agent

          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          KEY_ID=$(gpg --list-secret-keys --keyid-format=long | grep '^sec' | sed 's|.*/||;s| .*||' | head -n1)

          COMMIT_NAME="${{ secrets.COMMITTER_NAME }}"; [ -z "$COMMIT_NAME" ] && COMMIT_NAME="github-actions[bot]"
          COMMIT_EMAIL="${{ secrets.COMMITTER_EMAIL }}"; [ -z "$COMMIT_EMAIL" ] && COMMIT_EMAIL="41898282+github-actions[bot]@users.noreply.github.com"

          git config --global user.name "$COMMIT_NAME"
          git config --global user.email "$COMMIT_EMAIL"
          git config --global user.signingkey "$KEY_ID"
          git config --global gpg.program gpg
          git config --global commit.gpgsign true

          BRANCH="${{ steps.create_commit_pr.outputs.branch_name }}"
          git fetch origin "$BRANCH"
          git checkout -B "$BRANCH" "origin/$BRANCH"

          git add core/src/foss/golang/clash || true
          [ -f .gitmodules ] && git add .gitmodules || true

          if git diff --cached --quiet; then
            echo "No submodule pointer changes to commit (GPG)."
            exit 0
          fi

          git commit -m "Update submodule: core/src/foss/golang/clash"
          git push origin HEAD:"$BRANCH"

      - name: Commit submodule pointer (unsigned fallback)
        if: ${{ steps.create_commit_pr.outputs.has_submodule_change == 'true' && (secrets.SIGNING_SSH_PRIVATE_KEY == '' && secrets.GPG_PRIVATE_KEY == '') }}
        shell: bash
        run: |
          set -euo pipefail
          echo "No signing keys provided. Committing submodule pointer without signature (will show Unverified)."
          BRANCH="${{ steps.create_commit_pr.outputs.branch_name }}"
          git fetch origin "$BRANCH"
          git checkout -B "$BRANCH" "origin/$BRANCH"
          git add core/src/foss/golang/clash || true
          [ -f .gitmodules ] && git add .gitmodules || true
          if git diff --cached --quiet; then
            echo "No submodule pointer changes to commit (unsigned)."
            exit 0
          fi
          git commit -m "Update submodule: core/src/foss/golang/clash"
          git push origin HEAD:"$BRANCH"
